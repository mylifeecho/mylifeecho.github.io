---
layout: post
title: "TODO"
description: "TODO"
category: dev
tags: [ Haskell, Telegram, Bot ]
---
{% include JB/setup %}

# Intro

Recently Telegram rolled out their new update for [Telegram Bot API][telegram-bot-api] that introduced payments so now developers can build merchant bots. In this tutorial we are going to build a simple book store bot that would sell these wonderful [O'RLY books][orly-books] that teach as how to create better software. We will go through process of making a new bot from scratch, creating and debugging webhook, extending it to list goods and conduct payments using test payments provider. And all of that in Haskell!

# Step 0: Prerequisites

In order to start we need to

* register our bot with [@BotFather][botfather] and receive *bot token*. Keep it secret! See more information about registering your bot on official Telegram [page][reg-bot].
* obtain test *payment token* from [@BotFather][botfather]. Keep it secret too!

I assume you already have [stack][stack] and some [Haskell IDE][haskell-ide] installed. 

# Step 1: Initialize project

In this tutorial I'm going to use [telegram-api][telegram-api], Telegram Bot API bindings based on [Servant][servant] and Servant itself to create webhook for our bot. Telegram will call our webhook to notify our bot of user's actions. There are two ways of interaction with Telegram servers when webhook is called, you can directly answer Telegram's request with response to user action, but in this case you won't be able to know was your response successfully accepted by Telegram. Another option is to call telegram directly when you received webhook request. We are going to use the later one because it makes it simpler and telegram-api library gives us only this option.

We will create new bot project with name `orly-bookstore-bot` from `servant` template by running command:

```bash
stack orly-bookstore-bot servant
```

Explore newly created folder a bit to see what has been created from template and add these dependencies to `orly-bookstore-bot.cabal` to `library.build-depends` section. 

```yaml
library
  build-depends:
                     # other dependencies
                     , mtl
                     , http-client
                     , http-client-tls
                     , telegram-api >= 0.6.3.0
                     , text
                     , transformers
```

Now you can open `src/Libs.hs` file, remove everythig that is below imports except `startApp` function since it's exported. We will redefine `app` function that in this template is used for testing, but I wil skip testing aspect in this blog post. You can take a look at `test/Spec.hs` to gain more context on how you can test your bot.

# Step 1: Create version resource with Servant

Add these imports to the `src/Libs.hs` file:

```haskell
TODO: verify and update
import GHC.Generics
import Control.Monad.Reader
import Control.Monad.Except
import Data.Text
import Network.HTTP.Client (Manager)
import Network.HTTP.Client.TLS  (tlsManagerSettings)
import Data.Maybe
import Web.Telegram.API.Bot
import System.Environment
import qualifield aths_orly_booksstore_bot (version) as P
import Data.Version (showVersion)

```

Same for language extensions. These are very useful ones:

```haskell
TODO: verify and update
{-# LANGUAGE DeriveGeneric     #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE DeriveFunctor #-}
```

Some of the imports and extentions are not needed at the moment, but we will need them later.

Main idea of Servant is that your Web API can be defined and described entierly by the type and we are going to define this type for version page to start with and later extend it with webhook resource.

```haskell
-- We needed those language extensions to make it as simple as that
data Version = Version
  { version :: Text
  } deriving (Show, Generic)

instance ToJSON Version

-- At the moment Bot API consists of only version resource
-- that returns Version data record as JSON.
-- Thanks to Generic and ToJSON deriving Servant knows how
type BotAPI = "version" :> Get '[JSON] Version

botApi :: Proxy BotAPI
botApi = Proxy

startApp :: IO ()
startApp = do
  putStrLn "ORLY book store bot is starting..."
  run 8080 app

app :: Application
app = serve botApi botServer

-- actual server implementation
botServer :: Server BotAPI
botServer =
  returnVersion
    where version' = Version $ pack $ showVersion P.version
          returnVersion = return version'
```

**Important:** You have to add `Path_orly_bookstore_bot` to the list of exposed or other modules in your cabal file!
Otherwise it won't compile with very undescriptive message.

Run `stack build`. It should pull all dependencies and compile. 

Now you can run our bot with 

```
$ stack exec orly-bookstore-bot-exe
ORLY book store bot is starting...
```

and see the result with:

```
$ curl http://localhost:8080/version
{"version":"0.1.0.0"}
```

# Step 2: Create bot monad and data record with configuration

Let's define Bot monad transformer stack:

```haskell
newtype Bot a = Bot
    { runBot :: ReaderT BotConfig Handler a
    } deriving ( Functor, Applicative, Monad, MonadIO -- classes from base and transformers
                 MonadReader BotConfig, MonadError ServantErr) -- classes from mtl
```

where `Handler` here is Servant's Handler which is nothing more than type alias for `ExceptT ServantError IO`. 
`Bot` type is accompanied with classic set of deriving instances (don't forget to put `GeneralizedNewtypeDeriving` language extension on the top of the file). You can read more about it [here][mtl-transformers].

`BotConfig` is a read-only configuration that will be used by the bot. It will be data record that we will build on application start up.

```haskell
data BotConfig = BotConfig 
  { telegramToken :: Token
  , paymentsToken :: Text
  , manager :: Manager
  }

```

In order to initialize our bot with configuration let's change `startApp` and `app` functions. 
We will read bot settings from environment variables, build `BotCofig` and initialize our bot with it.

```haskell
startApp :: IO ()
startApp = do
  putStrLn "ORLY book store bot is starting..."
  env <- getEnvironment
  manager' <- newManager tlsManagerSettings
  let telegramToken' = fromJust $ lookup "TELEGRAM_TOKEN" env
      paymentsToken' = fromJust $ lookup "PAYMENTS_TOKEN" env
      config = BotConfig
        { telegramToken = Token $ pack telegramToken'
        , paymentsToken = pack paymentsToken'
        , manager = manager'
        }
  run 8080 $ app config

app :: BotConfig -> Application
app config = serve botApi $ initBotServer config
```

Now we need to change our `botServer` function signature to return `ServerT BotAPI Bot` because we want to work with `Bot` monad and implement `initBotServer` function that will do natural transformation for it.

```haskell
botServer :: ServerT BotAPI Bot
botServer =
  returnVersion
    where version' = Version $ pack $ showVersion P.version
          returnVersion :: Bot Version
          returnVersion = return version'

initBotServer :: BotConfig -> Server BotAPI
initBotServer config = enter (transform config) botServer
    where transform :: BotConfig -> Bot :~> ExceptT ServantErr IO
          transform config = Nat (flip runReaderT config . runBot)
```

Compile and run, at that point your bot should be returning version page as before. Note that even though we used unsafe functions `fromJust` to get tokens our application is working fine. Haskell is really lazy and it saves our application from crashing on start up.

# Add webhook

It's time to create a webhook for our bot! At first we will extend `BotAPI` type to have webhook resource defined.
For webhook we need to make sure that our bot accepts request only from Telegram's servers.
So as it's suggested in their [documentation][telegram-webhook] it's fine to use bot token itself as path parameter.
They will send POST request with `Update` object (from Telegram Bot API) to the webhook and we will validate token path parameter to authorize Telegram.
Servant library provides us `Capture` combinator that we will use to read the token.

The final version of the `BotAPI` looks like this:

```haskell
type BotAPI = "version" :> Get '[JSON] Version
         :<|> "webhook"
              :> Capture "secret" Text
              :> ReqBody '[JSON] Update
              :> Post '[JSON] ()
```

And we have to change `botServer` function again to add handler for webhook. Our bot will not compile before we do that. Type safety! We are going to use the same wiered operator `:<|>` that we used to add webhook to `BotAPI`.

```haskell

```


# First interaction (help command)
# Test your bot with Ngrok

```
ngrok http 8080
```

```
curl "https://api.telegram.org/bot$TELEGRAM_TOKEN/setWebhook?url=https://1b9f2ffd.ngrok.io/webhook/bot$TELEGRAM_TOKEN"
```

# List goods and send invoices
# Next steps

[mtl-transformers]: https://lexi-lambda.github.io/blog/2017/04/28/lifts-for-free-making-mtl-typeclasses-derivable/
